#include "main.h"
#include "MadgwickAHRS.h"
#include "stm32f1xx_hal_uart.h"

//###################################################################
#define VL6180X	0
#define MPU9250	0
#define DYN_ANEMO_PRESS 1
//###################################################################

//====================================================================
//			CAN ACCEPTANCE FILTER
//====================================================================
#define USE_FILTER	1
// Can accept until 4 Standard IDs
#define ID_1	0x01  //VL6180X
#define ID_2	0x02  //MPU9250
#define ID_3	0x03  //DYN_ANEMO_PRESS
#define ID_4	0x04
//====================================================================

UART_HandleTypeDef huart2;

extern void systemClock_Config(void);

void (*rxCompleteCallback) (void);
void can_callback(void);

CAN_Message      rxMsg;
CAN_Message      txMsg;
long int        counter = 0;

uint8_t* aTxBuffer[2];

extern float magCalibration[3];

void VL6180x_Init(void);
void VL6180x_Step(void);

int status;
int new_switch_state;
int switch_state = -1;

extern volatile int     connected;
extern volatile uint8_t set_connectable;
extern volatile uint8_t notification_enabled;

volatile uint8_t user_button_init_state = 1;
volatile uint8_t user_button_pressed = 0;


extern int pressure_subscription ;
extern int temperature_subscription ;

uint8_t sendFlag = 1;

#if MPU9250

float ax, ay, az, gx,gy, gz;
float rotationMatrix[5];
float angles[3] = {0.0f, 0.0f, 0.0f};
float phi = 0.0f, theta = 0.0f, psi = 0.0f;
int phiDegree, thetaDegree, psiDegree;
int16_t accelOutput[3];
int16_t gyroOutput[3];

#endif

#if VL6180X
uint32_t light;
uint16_t distance;
uint8_t LightOrDistance;
uint8_t succes;
#endif

#if DYN_ANEMO_PRESS
uint8_t motorState = 0;
uint8_t windVelocity = 0;
uint8_t motorRpmSend = 0;
uint8_t motorPositionSend = 0;
uint8_t motorRpmRec = 0;
uint8_t motorPositionRec = 0;
uint8_t positionOrVelocity = 0;

#endif

//====================================================================
// >>>>>>>>>>>>>>>>>>>>>>>>>> MAIN <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//====================================================================
int main(void)
{
	HAL_Init();
	systemClock_Config();
    SysTick_Config(HAL_RCC_GetHCLKFreq() / 1000); //SysTick end of count event each 1ms
	uart2_Init();
	uart3_Init();
	i2c1_Init();


#if DYN_ANEMO_PRESS
    anemo_Timer1Init();

#endif

	HAL_Delay(1000); // Wait

#if VL6180X
	uint8_t idLPS, idHTS;
    VL6180x_Init();
    hts221_activate();
    hts221_storeCalibration();
    idLPS = lps25hb_whoAmI();
    lps25hb_setup();
    idHTS = hts221_whoAmI();

    txMsg.id=0x41;
    txMsg.len=8;
    txMsg.format=CANStandard;
    txMsg.type=CANData;
#endif


#if MPU9250
    mpu9250_InitMPU9250();
    mpu9250_CalibrateMPU9250();


    txMsg.id=0x42;
    txMsg.len=6;
    txMsg.format=CANStandard;
    txMsg.type=CANData;

#if USE_MAGNETOMETER
    mpu9250_InitAK8963(magCalibration);
#endif
    uint8_t response=0;
	response =  mpu9250_WhoAmI();
	//term_printf("%d",response);
#endif


    can_Init();
    can_SetFreq(CAN_BAUDRATE); // CAN BAUDRATE : 500 MHz -- cf Inc/config.h
#if USE_FILTER
    can_Filter_list((ID_1<<21)|(ID_2<<5) , (ID_3<<21)|(ID_4<<5) , CANStandard, 0); // Accept until 4 Standard IDs
#else
    can_Filter_disable(); // Accept everybody
#endif
    can_IrqInit();
    can_IrqSet(&can_callback);
    dxl_setGoalVelocity(1, 140);

//    txMsg.id=0x55;
//    txMsg.data[0]=1;
//    txMsg.data[1]=2;
//    txMsg.len=3;
//    txMsg.format=CANStandard;
//    txMsg.type=CANData;

//    can_Write(txMsg);

    // Décommenter pour utiliser ce Timer ; permet de déclencher une interruption toutes les N ms
   tickTimer_Init(200); // period in ms

#if DYN_ANEMO_PRESS
//    TEST MOTEUR
    dxl_LED(1, LED_ON);
    HAL_Delay(500);
    dxl_LED(1, LED_OFF);
    HAL_Delay(500);

    dxl_torque(1, TORQUE_OFF);
    dxl_setOperatingMode(1,VELOCITY_MODE);
    dxl_torque(1, TORQUE_ON);
    dxl_setGoalVelocity(1, 50);
    HAL_Delay(5000);
    dxl_setGoalVelocity(1,140);
    HAL_Delay(2000);
    dxl_setGoalVelocity(1,0);

    txMsg.id=0x43;
    txMsg.len=3;
    txMsg.format=CANStandard;
    txMsg.type=CANData;
#endif


    while (1) {

#if DYN_ANEMO_PRESS
    	DYN_ANEMO_PRESS_callBack();
    	canSendMessage();

#endif

#if VL6180X
	VL6180x_Step();
	light_distance_callBack();
	PTH_callBack();
	canSendMessage();


#endif



#if MPU9250
    mpu9250_Step();
    MPU9250_callBack();
    canSendMessage();

#endif

    }
	return 0;
}

#if DYN_ANEMO_PRESS

void DYN_ANEMO_PRESS_callBack(void){

	windVelocity = (anemo_GetCount()*5)/4;
	if(windVelocity > 5){
		 dxl_setGoalVelocity(1, 140);
	}
	else{
		dxl_setGoalVelocity(1, 0);
	}
	if(motorState){
		if(positionOrVelocity){
			      dxl_setGoalVelocity(1, motorRpmRec);
		           }
		       else{
		          dxl_setGoalPosition(1, motorPositionRec);
		           }
	    }
		else{
			if(positionOrVelocity){
		     	dxl_setGoalVelocity(1,0);
			         }
	        else{
	            dxl_setGoalPosition(1,0);
		           }
		}
	}

//	if((windVelocity > 20) & (motorState = 1)){
//       if(positionOrVelocity){
//	      dxl_setGoalVelocity(1, motorRpmRec);
//           }
//       else{
//          dxl_setGoalPosition(1, motorPositionRec);
//           }
//
//	    }

	    motorRpmSend  = dxl_getPresentVelocity(1);
	    motorPositionSend = dxl_getPresentPosition(1);

	    txMsg.data[0] = motorRpmSend;
	    txMsg.data[1] = motorPositionSend;
	    txMsg.data[2] = windVelocity;
}

#endif

#if MPU9250

void MPU9250_callBack(void){



	mpu9250_ReadAccelData(accelOutput);
	mpu9250_ReadGyroData(gyroOutput);

	ax = accelOutput[0] * (4.0f / 32768.0f);
	ay = accelOutput[1] *dxl_setGoalVelocity(1, 140); (4.0f / 32768.0f);
	az = accelOutput[2] * (4.0f / 32768.0f);
	gx = gyroOutput[0] * ((1000.0f / 32768.0f)*(M_PI / 180.0f));
	gy = gyroOutput[1] * ((1000.0f / 32768.0f)*(M_PI / 180.0f));
	gz = gyroOutput[2] * ((1000.0f / 32768.0f)*(M_PI / 180.0f));

	// MADGWICK METHOD TO AVOID GIMBAL LOCK PROBLEM
	MadgwickAHRSupdateIMU(gx, gy, gz, ax, ay, az);

    //MATRIX VARIABLESpositionOrVelocity
	rotationMatrix[0] = 2 * ((q1 *q2) + (q0 * q3));
	rotationMatrix[1] = ((q0*q0) + (q1*q1) - (q2*q2) - (q3*q3));
	rotationMatrix[2] = 2*((q0*q1) + (q2*q3));
	rotationMatrix[3] = 2*((q1*q3) - (q0*q2));
	rotationMatrix[4] = ((q0*q0) - (q1*q1) - (q2*q2) + (q3*q3));

	phi = atan2f(rotationMatrix[2], rotationMatrix[4]);
	theta = -asinf(rotationMatrix[3]);
	psi = atan2f(rotationMdxl_setGoalVelocity(1, 140);atrix[0], rotationMatrix[1]);

	phiDegree = (phi * 180.0f/M_PI);
	thetaDegree = (theta * 180.0f/M_PI);
	psiDegree = (psi * 180.0f/M_PI);
//    angles[0] = phi * 180.0f/M_PI;
//    		angles[1] = theta * 180.0f/M_PI;
//    				angles[2] = psi * 180.0f/M_PI;

	txMsg.data[0] = (phiDegree >> 8) & 0xFF;
	txMsg.data[1] = (phiDegree) & 0x00FF;
	txMsg.data[2] = (thetaDegree >> 8) & 0xFF;
	txMsg.data[3] = (thetaDegree) & 0x00FF;
	txMsg.data[4] = (psiDegree) & 0xFF;
	txMsg.data[5] = (psiDegree >> 8) & 0x00FF;
//		char message[100];
//
//		snprintf(message, sizeof(message), " f= %d, t:%d, s: %d \r\n", (int)(phiDegree), (int)(thetaDegree), (int)(psiDegree));
//positionOrVelocity
//		HAL_UART_Transmit(&Uart2Handle, (uint8_t*)message, strlen(message), HAL_MAX_DELAY);
//	HAL_Delay(500);
}

#endif

#if VL6180X

void light_distance_callBack(void){

	if(LightOrDistance){
	    txMsg.data[0] = (Als.lux >> 24) & 0xFF;
	    txMsg.data[1] = (Als.lux >> 16) & 0x00FF;
	    txMsg.data[2] = (Als.lux >> 8) & 0x0000FF;
	    txMsg.data[3] = (Als.lux) & 0x000000FF;
	}
	else{
		txMsg.data[0] = (range >> 8) & 0xFF;
		txMsg.data[1] = (range) & 0x00FF;
		txMsg.data[2] = 0x00;
	    txMsg.data[3] = 0x00;
	}

}


void PTH_callBack(void){
	static float pressure, temp_lps25hb, temp_hts221, humidity;

	succes = lps25hb_getPressure(&pressure);
    succes = lps25hb_getTemperature(&temp_lps25hb);
	succes = hts221_getTemperature(&temp_hts221);
	succes = hts221_getHumidity(&humidity);


    txMsg.data[4] = (uint8_t)(pressure);
    txMsg.data[5] = (uint8_t)(humidity);
    txMsg.data[6] = (uint8_t)(temp_lps25hb);
    txMsg.data[7] = (uint8_t)(temp_hts221);

}

#endif
//====================================================================
//			CAN CALLBACK
//====================================================================

void canSendMessage(void){
	if (sendFlag == 1){
		can_Write(txMsg);
		HAL_Delay(500);
//		sendFlag = 0;
	}
}
void can_callback(void)
{
	CAN_Message msg_rcv;
	can_Read(&msg_rcv);


#if VL6180X

	if(msg_rcv.id == ID_1){
		if(msg_rcv.data[0] == 0x01){
			LightOrDistance = 0;
			txMsg.id = 0x40;
		}
		else if(msg_rcv.data[0] == 0x02) {
			LightOrDistance = 1;
			txMsg.id = 0x41;
		}
	}

#endif

#if MPU9250

#endif

#if DYN_ANEMO_PRESS

	if(msg_rcv.id == ID_3){

	   if(msg_rcv.data[2] == 0x01){
		//STOP MOTOR
		motorState = 0;
		dxl_torque(1, TORQUE_OFF);
			}
		else if(msg_rcv.data[2] == 0x02) {
//	    	START MOTOR
//			dxl_LED(1, LED_ON);
//			HAL_Delay(100);
//			dxl_LED(1, LED_OFF);
//			HAL_Delay(100);
//			dxl_LED(1, LED_ON);
//			HAL_Delay(100);
//			dxl_LED(1, LED_OFF);
			motorState = 1;

			}
		else if(msg_rcv.data[2] == 0x03){
			dxl_setOperatingMode(1, POSITION_MODE);
			motorPositionRec = (uint8_t)msg_rcv.data[1];
			positionOrVelocity = 0;
			}
		else if(msg_rcv.data[2] == 0x04){
//			dxl_setOperatingMode(1, VELOCITY_MODE);
//			dxl_torque(1, TORQUE_ON);
			motorRpmRec = (uint8_t)msg_rcv.data[1];
			positionOrVelocity = 1;
			}
		}

#endif

}
//====================================================================
//			TIMER CALLBACK PERIOD
//===================================================================

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
#if DYN_ANEMO_PRESS
    anemo_ResetCount();
#endif

#if VL6180X

#endif

    //term_printf("from timer interrupt\n\r");
}
//====================================================================



#if VL6180X
void VL6180x_Init(void)
{
	uint8_t id;
	State.mode = 1;

    XNUCLEO6180XA1_Init();
    HAL_Delay(500); // Wait
    // RESET
    XNUCLEO6180XA1_Reset(0);
    HAL_Delay(10);
    XNUCLEO6180XA1_Reset(1);
    HAL_Delay(1);

    HAL_Delay(10);
    VL6180x_WaitDeviceBooted(theVL6180xDev);
    id=VL6180x_Identification(theVL6180xDev);
    term_printf("id=%d, should be 180 (0xB4) \n\r", id);
    VL6180x_InitData(theVL6180xDev);

    State.InitScale=VL6180x_UpscaleGetScaling(theVL6180xDev);
    State.FilterEn=VL6180x_FilterGetState(theVL6180xDev);

     // Enable Dmax calculation only if value is displayed (to save computation power)
    VL6180x_DMaxSetState(theVL6180xDev, DMaxDispTime>0);

    switch_state=-1 ; // force what read from switch to set new working mode
    State.mode = AlrmStart;
}
//====================================================================
void VL6180x_Step(void)
{
    DISP_ExecLoopBody();

    new_switch_state = LightOrDistance;
    if (new_switch_state != switch_state) {
        switch_state=new_switch_state;
        status = VL6180x_Prepare(theVL6180xDev);
        // Increase convergence time to the max (this is because proximity config of API is used)
        VL6180x_RangeSetMaxConvergenceTime(theVL6180xDev, 63);
        if (status) {
            AbortErr("ErIn");
        }
        else{
            if (switch_state == SWITCH_VAL_RANGING) {
                VL6180x_SetupGPIO1(theVL6180xDev, GPIOx_SELECT_GPIO_INTERRUPT_OUTPUT, INTR_POL_HIGH);
                VL6180x_ClearAllInterrupt(theVL6180xDev);
                State.ScaleSwapCnt=0;
                DoScalingSwap( State.InitScale);
            } else {
                 State.mode = RunAlsPoll;
                 InitAlsMode();
            }
        }
    }

    switch (State.mode) {
    case RunRangePoll:
        RangeState();
        break;

    case RunAlsPoll:
        AlsState();
        break;

    case InitErr:
        TimeStarted = g_TickCnt;
        State.mode = WaitForReset;
        break;

    case AlrmStart:
       GoToAlaramState();
       break;

    case AlrmRun:
        AlarmState();
        break;

    case FromSwitch:
        // force reading swicth as re-init selected mode
        switch_state=!XNUCLEO6180XA1_GetSwitch();
        break;

    case ScaleSwap:

        if (g_TickCnt - TimeStarted >= ScaleDispTime) {
            State.mode = RunRangePoll;
            TimeStarted=g_TickCnt; /* reset as used for --- to er display */
        }
        else
        {
        	DISP_ExecLoopBody();
        }
        break;

    default: {
    	 DISP_ExecLoopBody();
          if (g_TickCnt - TimeStarted >= 5000) {
              NVIC_SystemReset();
          }
    }
    }
}

#endif
